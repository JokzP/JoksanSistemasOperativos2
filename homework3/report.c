#define _GNU_SOURCE
#include <stdio.h>
#include "scheduler.h"
#include "algorithms.h"
#include "metrics.h"

void generate_report(const char *filename, process_t *processes, int n) {
    FILE *f = fopen(filename, "w");
    if (!f) {
        perror("fopen");
        return;
    }

    fprintf(f, "# Scheduler Performance Report\n\n");

    fprintf(f, "## Process Set\n");
    fprintf(f, "| PID | Arrival | Burst | Priority |\n");
    fprintf(f, "|-----|---------|-------|----------|\n");
    for (int i = 0; i < n; i++) {
        fprintf(f, "| %d | %d | %d | %d |\n",
                processes[i].pid,
                processes[i].arrival_time,
                processes[i].burst_time,
                processes[i].priority);
    }
    fprintf(f, "\n");

    /* For brevity, we only simulate FIFO and RR(q=3) here as an example. */
    const char *alg_names[] = { "FIFO", "SJF", "STCF", "RR(q=3)", "MLFQ" };
    metrics_t metrics[5];

    process_t tmp[ MAX_PROCESSES ];
    timeline_event_t timeline[ MAX_TIMELINE_EVENTS ];
    int tlen;

    /* FIFO */
    for (int i = 0; i < n; i++) tmp[i] = processes[i];
    schedule_fifo(tmp, n, timeline, &tlen);
    int total_time = timeline[tlen-1].time + timeline[tlen-1].duration;
    int busy = total_time;
    calculate_metrics(tmp, n, total_time, busy, &metrics[0]);

    /* SJF */
    for (int i = 0; i < n; i++) tmp[i] = processes[i];
    schedule_sjf(tmp, n, timeline, &tlen);
    total_time = timeline[tlen-1].time + timeline[tlen-1].duration;
    busy = total_time;
    calculate_metrics(tmp, n, total_time, busy, &metrics[1]);

    /* STCF */
    for (int i = 0; i < n; i++) tmp[i] = processes[i];
    schedule_stcf(tmp, n, timeline, &tlen);
    total_time = timeline[tlen-1].time + timeline[tlen-1].duration;
    busy = total_time;
    calculate_metrics(tmp, n, total_time, busy, &metrics[2]);

    /* RR(q=3) */
    for (int i = 0; i < n; i++) tmp[i] = processes[i];
    schedule_rr(tmp, n, 3, timeline, &tlen);
    total_time = timeline[tlen-1].time + timeline[tlen-1].duration;
    busy = total_time;
    calculate_metrics(tmp, n, total_time, busy, &metrics[3]);

    /* MLFQ simple config */
    mlfq_config_t cfg;
    int quanta[3] = {2, 4, 8};
    cfg.num_queues = 3;
    cfg.quantums = quanta;
    cfg.boost_interval = 20;
    for (int i = 0; i < n; i++) tmp[i] = processes[i];
    schedule_mlfq(tmp, n, &cfg, timeline, &tlen);
    total_time = timeline[tlen-1].time + timeline[tlen-1].duration;
    busy = total_time;
    calculate_metrics(tmp, n, total_time, busy, &metrics[4]);

    fprintf(f, "## Algorithm Comparison\n\n");
    fprintf(f, "| Algorithm | Avg TAT | Avg WT | Avg RT | Throughput |\n");
    fprintf(f, "|-----------|---------|--------|--------|------------|\n");
    for (int i = 0; i < 5; i++) {
        fprintf(f, "| %s | %.2f | %.2f | %.2f | %.2f |\n",
                alg_names[i],
                metrics[i].avg_turnaround_time,
                metrics[i].avg_waiting_time,
                metrics[i].avg_response_time,
                metrics[i].throughput);
    }

    fprintf(f, "\n## Notes\n");
    fprintf(f, "This report was auto-generated by the scheduler simulator.\n");

    fclose(f);
}
